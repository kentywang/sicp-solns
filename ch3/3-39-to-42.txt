3.39:
100, 121, 101
Edit: 11 too?

3.40:
(define x 10)
(parallel-execute 
 (lambda () (set! x (* x x)))
 (lambda () (set! x (* x x x))))

Legend:
P1: first process
P2: second process
A: access first x
B: access second x
C: access third x
S: set x

P1, P2: 1,000,000
P2, P1: 1,000,000
P1_A, P2_A_B_C_S, P1_B_S: 10,000
P1_A, P2_A, P1_B_S, P2_B_C_S: 100,000
P1_A, P2_A_B, P1_B_S, P2_C_S: 10,000
P1_A, P2_A_B_C, P1_B_S, P2_S: 1,000
P1_A_B, P2_A_B_C_S, P1_S: 100

And many more permutations that return the same values. Suffice to say,
this is unmanageable.

Were it serialized, only 1,000,000 is a possibility.

3.41:
With or without serialization of withdrawal and deposits, there shouldn't
be a need to serialize read access of account balance because it cannot
affect the other processes, even if it interleaves with them.

3.42:
The problem with this is that while different serialized procedures behave
the same in a concurrency situation, a procedure can be interleaved with
another of its kind. For instance, withdrawals can be interleaved with
other withdrawals.
